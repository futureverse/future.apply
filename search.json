[{"path":[]},{"path":"https://future.apply.futureverse.org/CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"interest fostering open welcoming environment, contributors maintainers pledge making participation project community harassment-free experience everyone, regardless age, body size, disability, ethnicity, gender identity expression, level experience, nationality, personal appearance, race, religion, sexual identity orientation.","code":""},{"path":"https://future.apply.futureverse.org/CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes creating positive environment include: Using welcoming inclusive language respectful differing viewpoints experiences Gracefully accepting constructive criticism Focusing best community Showing empathy towards community members Examples unacceptable behavior participants include: use sexualized language imagery unwelcome sexual attention advances Trolling, insulting/derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical electronic address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://future.apply.futureverse.org/CONDUCT.html","id":"our-responsibilities","dir":"","previous_headings":"","what":"Our Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Project maintainers responsible clarifying standards acceptable behavior expected take appropriate fair corrective action response instances unacceptable behavior. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, ban temporarily permanently contributor behaviors deem inappropriate, threatening, offensive, harmful.","code":""},{"path":"https://future.apply.futureverse.org/CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within project spaces public spaces individual representing project community. Examples representing project community include using official project e-mail address, posting via official social media account, acting appointed representative online offline event. Representation project may defined clarified project maintainers.","code":""},{"path":"https://future.apply.futureverse.org/CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported contacting project team. complaints reviewed investigated result response deemed necessary appropriate circumstances. project team obligated maintain confidentiality regard reporter incident. details specific enforcement policies may posted separately. Project maintainers follow enforce Code Conduct good faith may face temporary permanent repercussions determined members project’s leadership.","code":""},{"path":"https://future.apply.futureverse.org/CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 1.4, available http://contributor-covenant.org/version/1/4","code":""},{"path":"https://future.apply.futureverse.org/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to the ‘future.apply’ package","title":"Contributing to the ‘future.apply’ package","text":"Git repository uses Git Flow branching model (git flow extension useful ). develop branch contains latest contributions code appear next release, master branch contains code latest release, exactly currently CRAN. Contributing package easy. Just send pull request. send PR, make sure develop destination branch future.apply repository. PR pass R CMD check ---cran, also checked GitHub Actions PR submitted. abide Code Conduct Contributor Covenant.","code":""},{"path":"https://future.apply.futureverse.org/articles/future.apply-1-overview.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A Future for R: Apply Function to Elements in Parallel","text":"purpose package provide worry-free parallel alternatives base-R “apply” functions, e.g. apply(), lapply(), vapply(). goal one able replace core futurized equivalent things just work. example, instead : one can : Reproducibility part core design, means perfect, parallel random number generation (RNG) supported regardless amount chunking, type load balancing, future backend used. enable parallel RNG, use argument future.seed = TRUE.","code":"library(datasets) library(stats) y <- lapply(mtcars, FUN = mean, trim = 0.10) library(future.apply) plan(multisession) ## Run in parallel on local computer  library(datasets) library(stats) y <- future_lapply(mtcars, FUN = mean, trim = 0.10)"},{"path":"https://future.apply.futureverse.org/articles/future.apply-1-overview.html","id":"role","dir":"Articles","previous_headings":"","what":"Role","title":"A Future for R: Apply Function to Elements in Parallel","text":"future.apply package fit software stack? can think sibling foreach, furrr, BiocParallel, plyr, etc. Just parallel provides parLapply(), foreach provides foreach(), BiocParallel provides bplapply(), plyr provides llply(), future.apply provides future_lapply(). table summarizing idea: Note , except built-parallel package, none higher-level APIs implement parallel backends, rather enhance existing ones. foreach framework leverages backends doParallel, doMC doFuture, future.apply framework leverages future ecosystem therefore backends built-parallel, future.callr, future.batchtools. separating future_lapply() friends future package, helps clarifying purpose future package, define provide core Future API, higher-level parallel APIs can build futurized parallel backends can plugged . API identity future.apply package kept close *apply() functions base R. words, neither keep growing expanded new, powerful apply-like functions beyond core ones base R. extended functionality part separate package.","code":""},{"path":"https://future.apply.futureverse.org/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Henrik Bengtsson. Author, maintainer, copyright holder. R Core Team. Copyright holder, contributor.","code":""},{"path":"https://future.apply.futureverse.org/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Henrik Bengtsson, Unifying Framework Parallel Distributed Processing R using Futures, R Journal (2021) 13:2, pages 208-227, doi:10.32614/RJ-2021-048","code":"@Article{RJ-2021-048,   author = {Henrik Bengtsson},   title = {A Unifying Framework for Parallel and Distributed Processing in R using Futures},   year = {2021},   journal = {The R Journal},   doi = {10.32614/RJ-2021-048},   url = {https://doi.org/10.32614/RJ-2021-048},   pages = {208--227},   volume = {13},   number = {2}, }"},{"path":[]},{"path":"https://future.apply.futureverse.org/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Apply Function to Elements in Parallel using Futures","text":"purpose package provide worry-free parallel alternatives base-R “apply” functions, e.g. apply(), lapply(), vapply(). goal one able replace core futurized equivalent things just work. example, instead : one can : Reproducibility part core design, means perfect, parallel random number generation (RNG) supported regardless amount chunking, type load balancing, future backend used. enable parallel RNG, use argument future.seed = TRUE.","code":"library(datasets) library(stats) y <- lapply(mtcars, FUN = mean, trim = 0.10) library(future.apply) plan(multisession) ## Run in parallel on local computer  library(datasets) library(stats) y <- future_lapply(mtcars, FUN = mean, trim = 0.10)"},{"path":"https://future.apply.futureverse.org/index.html","id":"role","dir":"","previous_headings":"","what":"Role","title":"Apply Function to Elements in Parallel using Futures","text":"future.apply package fit software stack? can think sibling foreach, furrr, BiocParallel, plyr, etc. Just parallel provides parLapply(), foreach provides foreach(), BiocParallel provides bplapply(), plyr provides llply(), future.apply provides future_lapply(). table summarizing idea: Note , except built-parallel package, none higher-level APIs implement parallel backends, rather enhance existing ones. foreach framework leverages backends doParallel, doMC doFuture, future.apply framework leverages future ecosystem therefore backends built-parallel, future.callr, future.batchtools. separating future_lapply() friends future package, helps clarifying purpose future package, define provide core Future API, higher-level parallel APIs can build futurized parallel backends can plugged . API identity future.apply package kept close *apply() functions base R. words, neither keep growing expanded new, powerful apply-like functions beyond core ones base R. extended functionality part separate package.","code":""},{"path":"https://future.apply.futureverse.org/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Apply Function to Elements in Parallel using Futures","text":"R package future.apply available CRAN can installed R :","code":"install.packages(\"future.apply\")"},{"path":"https://future.apply.futureverse.org/index.html","id":"pre-release-version","dir":"","previous_headings":"Installation","what":"Pre-release version","title":"Apply Function to Elements in Parallel using Futures","text":"install pre-release version available Git branch develop GitHub, use: install package source.","code":"remotes::install_github(\"futureverse/future.apply\", ref=\"develop\")"},{"path":"https://future.apply.futureverse.org/reference/fold.html","id":null,"dir":"Reference","previous_headings":"","what":"Efficient Fold, Reduce, Accumulate, Combine of a Vector — fold","title":"Efficient Fold, Reduce, Accumulate, Combine of a Vector — fold","text":"Efficient Fold, Reduce, Accumulate, Combine Vector","code":""},{"path":"https://future.apply.futureverse.org/reference/fold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efficient Fold, Reduce, Accumulate, Combine of a Vector — fold","text":"","code":"fold(x, f, left = TRUE, unname = TRUE, threshold = 1000L)"},{"path":"https://future.apply.futureverse.org/reference/fold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Efficient Fold, Reduce, Accumulate, Combine of a Vector — fold","text":"x vector. f binary function, .e. function take takes two arguments. left TRUE, vector combined left (first element), otherwise right (last element). unname TRUE, function f called f(unname(y), x[[ii]]), otherwise f(y, x[[ii]]), may introduce name \"y\". threshold integer (>= 2) specifying length recursive divide--conquer call stop incremental building partial value performed.  Using threshold = +Inf disable recursive folding.","code":""},{"path":"https://future.apply.futureverse.org/reference/fold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Efficient Fold, Reduce, Accumulate, Combine of a Vector — fold","text":"vector.","code":""},{"path":"https://future.apply.futureverse.org/reference/fold.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Efficient Fold, Reduce, Accumulate, Combine of a Vector — fold","text":"order recursive folding give results non-recursive folding, binary function f must associative , .e. f(f(x[[1]], x[[2]]), x[[3]]) equals f(x[[1]], f(x[[2]]), x[[3]]). function efficient (memory speed) Reduce(f, x, right = !left, accumulate = FALSE), especially x long.","code":""},{"path":"https://future.apply.futureverse.org/reference/future.apply.html","id":null,"dir":"Reference","previous_headings":"","what":"future.apply: Apply Function to Elements in Parallel using Futures — future.apply","title":"future.apply: Apply Function to Elements in Parallel using Futures — future.apply","text":"future.apply packages provides parallel implementations common \"apply\" functions provided base R.  parallel processing performed via future ecosystem, provides large number parallel backends, e.g. local machine, remote cluster, high-performance compute cluster.","code":""},{"path":"https://future.apply.futureverse.org/reference/future.apply.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"future.apply: Apply Function to Elements in Parallel using Futures — future.apply","text":"Currently implemented functions : future_apply(): parallel version apply() future_by(): parallel version () future_eapply(): parallel version eapply() future_lapply(): parallel version lapply() future_mapply(): parallel version mapply() future_sapply(): parallel version sapply() future_tapply(): parallel version tapply() future_vapply(): parallel version vapply() future_Map(): parallel version Map() future_replicate(): parallel version replicate() future_.mapply(): parallel version .mapply() Reproducibility part core design, means perfect, parallel random number generation (RNG) supported regardless amount chunking, type load balancing, future backend used. Since future_*() functions arguments corresponding base R function, start using often simple renaming function code.  example, attaching package:   code :   can updated :   default settings future framework process code sequentially.  run parallel local machine (operating system), use:   first.  ! go back sequential processing, use plan(sequential). access multiple machines local network, use:   set four workers, one n1 n3, two n2. SSH access remote machines, use:   See future package future::plan() examples. future.batchtools package provides support high-performance compute (HPC) cluster schedulers SGE, Slurm, TORQUE / PBS. example, plan(batchtools_slurm): Process via Slurm scheduler job queue. plan(batchtools_torque): Process via TORQUE / PBS scheduler job queue. builds top queuing framework batchtools package provides. details backend configuration, please see future.batchtools batchtools packages. just examples parallel/distributed backend future ecosystem.  alternatives, see 'Reverse dependencies' section future CRAN package page.","code":"library(future.apply) x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE)) y <- lapply(x, quantile, probs = 1:3/4) y <- future_lapply(x, quantile, probs = 1:3/4) plan(multisession) plan(cluster, workers = c(\"n1\", \"n2\", \"n2\", \"n3\")) plan(cluster, workers = c(\"m1.myserver.org\", \"m2.myserver.org))"},{"path":[]},{"path":"https://future.apply.futureverse.org/reference/future.apply.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"future.apply: Apply Function to Elements in Parallel using Futures — future.apply","text":"Henrik Bengtsson, except implementations future_apply(), future_Map(), future_replicate(), future_sapply(), future_tapply(), adopted source code corresponding base R functions, licensed GPL (>= 2) 'R Core Team' copyright holder. dependencies, license package GPL (>= 2).","code":""},{"path":"https://future.apply.futureverse.org/reference/future.apply.options.html","id":null,"dir":"Reference","previous_headings":"","what":"Options used for future.apply — future.apply.options","title":"Options used for future.apply — future.apply.options","text":"R options environment variables used future.apply package packages enhancing .WARNING: Note names default values options may change future versions package.  Please use care notice.","code":""},{"path":"https://future.apply.futureverse.org/reference/future.apply.options.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Options used for future.apply — future.apply.options","text":"settings specific future package, see future::future.options page.","code":""},{"path":"https://future.apply.futureverse.org/reference/future.apply.options.html","id":"options-for-debugging-future-apply","dir":"Reference","previous_headings":"","what":"Options for debugging future.apply","title":"Options used for future.apply — future.apply.options","text":"future.apply.debug: (logical) TRUE, extensive debug messages generated. (Default: FALSE)","code":""},{"path":"https://future.apply.futureverse.org/reference/future.apply.options.html","id":"environment-variables-that-set-r-options","dir":"Reference","previous_headings":"","what":"Environment variables that set R options","title":"Options used for future.apply — future.apply.options","text":"R future.apply.* options can set corresponding environment variable R_FUTURE_APPLY_* future.apply package loaded. example, R_FUTURE_APPLY_DEBUG=TRUE, option future.apply.debug set TRUE (logical).","code":""},{"path":[]},{"path":"https://future.apply.futureverse.org/reference/future.apply.options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Options used for future.apply — future.apply.options","text":"","code":"if (FALSE) { # \\dontrun{ options(future.apply.debug = TRUE) } # }"},{"path":"https://future.apply.futureverse.org/reference/future_apply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Functions Over Array Margins via Futures — future_apply","title":"Apply Functions Over Array Margins via Futures — future_apply","text":"future_apply() implements base::apply() using future perfect replication results, regardless future backend used. returns vector array list values obtained applying function margins array matrix.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_apply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Functions Over Array Margins via Futures — future_apply","text":"","code":"future_apply(   X,   MARGIN,   FUN,   ...,   simplify = TRUE,   future.envir = parent.frame(),   future.stdout = TRUE,   future.conditions = \"condition\",   future.globals = TRUE,   future.packages = NULL,   future.seed = FALSE,   future.scheduling = 1,   future.chunk.size = NULL,   future.label = \"future_apply-%d\" )"},{"path":"https://future.apply.futureverse.org/reference/future_apply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Functions Over Array Margins via Futures — future_apply","text":"X array, including matrix. MARGIN vector giving subscripts function applied . example, matrix 1 indicates rows, 2 indicates columns, c(1, 2) indicates rows columns. X named dimnames, can character vector selecting dimension names. FUN function taking least one argument. simplify logical indicating whether results simplified possible. future.envir environment passed argument envir future::future() -. future.stdout TRUE (default), standard output underlying futures captured, re-outputted soon possible. FALSE, output silenced (sinking null device outputted). NA (recommended), output intercepted. future.conditions character string conditions classes captured relayed.  default condition argument future::Future(). intercept conditions, use conditions = character(0L). Errors always relayed. future.globals logical, character vector, named list controlling globals handled. details, see section. future.packages (optional) character vector specifying packages attached R environment evaluating future. future.seed logical integer (length one seven), list length(X) pre-generated random seeds. details, see section. future.scheduling Average number futures (\"chunks\") per worker. 0.0, single future used process elements X. 1.0 TRUE, one future per worker used. 2.0, worker process two futures (enough elements X). Inf FALSE, one future per element X used. used future.chunk.size NULL. future.chunk.size average number elements per future (\"chunk\"). Inf, elements processed single future. NULL, argument future.scheduling used. future.label character string, future assigned label sprintf(future.label, chunk_idx).  TRUE, future.label = \"future_lapply-%d\".  FALSE, labels assigned. ... (optional) Additional arguments passed FUN(), except future.* arguments, passed future_lapply() used internally.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_apply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Functions Over Array Margins via Futures — future_apply","text":"Returns vector array list values obtained applying function margins array matrix. See base::apply() details.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_apply.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Apply Functions Over Array Margins via Futures — future_apply","text":"implementations future_apply() adopted source code corresponding base R function, licensed GPL (>= 2) 'R Core Team' copyright holder.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_apply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Functions Over Array Margins via Futures — future_apply","text":"","code":"## --------------------------------------------------------- ## apply() ## --------------------------------------------------------- X <- matrix(c(1:4, 1, 6:8), nrow = 2L)  Y0 <- apply(X, MARGIN = 1L, FUN = table) Y1 <- future_apply(X, MARGIN = 1L, FUN = table) print(Y1) #> [[1]] #> ...future.X_jj #> 1 3 7  #> 2 1 1  #>  #> [[2]] #> ...future.X_jj #> 2 4 6 8  #> 1 1 1 1  #>  stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME  Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile) Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile) print(Y1) #>      [,1] [,2] #> 0%      1  2.0 #> 25%     1  3.5 #> 50%     2  5.0 #> 75%     4  6.5 #> 100%    7  8.0 stopifnot(all.equal(Y1, Y0))   ## --------------------------------------------------------- ## Parallel Random Number Generation ## --------------------------------------------------------- # \\donttest{ ## Regardless of the future plan, the number of workers, and ## where they are, the random numbers produced are identical  X <- matrix(c(1:4, 1, 6:8), nrow = 2L)  plan(multisession) set.seed(0xBEEF) Y1 <- future_apply(X, MARGIN = 1L, FUN = sample, future.seed = TRUE) print(Y1) #>      [,1] [,2] #> [1,]    3    8 #> [2,]    1    6 #> [3,]    7    2 #> [4,]    1    4  plan(sequential) set.seed(0xBEEF) Y2 <- future_apply(X, MARGIN = 1L, FUN = sample, future.seed = TRUE) print(Y2) #>      [,1] [,2] #> [1,]    3    8 #> [2,]    1    6 #> [3,]    7    2 #> [4,]    1    4  stopifnot(all.equal(Y1, Y2)) # }"},{"path":"https://future.apply.futureverse.org/reference/future_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a Function to a Data Frame Split by Factors via Futures — future_by","title":"Apply a Function to a Data Frame Split by Factors via Futures — future_by","text":"Apply Function Data Frame Split Factors via Futures","code":""},{"path":"https://future.apply.futureverse.org/reference/future_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a Function to a Data Frame Split by Factors via Futures — future_by","text":"","code":"future_by(   data,   INDICES,   FUN,   ...,   simplify = TRUE,   future.envir = parent.frame() )"},{"path":"https://future.apply.futureverse.org/reference/future_by.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a Function to a Data Frame Split by Factors via Futures — future_by","text":"data R object, normally data frame, possibly matrix. INDICES factor list factors, length nrow(data). FUN function applied (usually data-frame) subsets data. simplify logical: see base::tapply(). future.envir environment passed argument envir future::future() -. ... Additional arguments pass future_lapply() FUN().","code":""},{"path":"https://future.apply.futureverse.org/reference/future_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a Function to a Data Frame Split by Factors via Futures — future_by","text":"object class \"\", giving results subset. always list simplify false, otherwise list array (see base::tapply()). See also base::() details.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_by.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a Function to a Data Frame Split by Factors via Futures — future_by","text":"Internally, data grouped INDICES list data subset elements processed future_lapply(). groups differ significantly size, processing time may differ significantly groups. correct processing-time imbalances, adjust amount chunking via arguments future.scheduling future.chunk.size.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_by.html","id":"note-on-stringsasfactors-","dir":"Reference","previous_headings":"","what":"Note on 'stringsAsFactors'","title":"Apply a Function to a Data Frame Split by Factors via Futures — future_by","text":"future_by() modeled closely possible behavior base::().  functions \"default\" S3 methods calls data <- .data.frame(data) internally.  call may turn call S3 method .data.frame() coerces strings factors depending whether stringsAsFactors argument default . example, S3 method .data.frame() lists changed (effective) default stringsAsFactors = TRUE stringsAsFactors = TRUE R 4.0.0.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_by.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a Function to a Data Frame Split by Factors via Futures — future_by","text":"","code":"## --------------------------------------------------------- ## by() ## --------------------------------------------------------- library(datasets) ## warpbreaks library(stats)    ## lm()  y0 <- by(warpbreaks, warpbreaks[,\"tension\"],          function(x) lm(breaks ~ wool, data = x))  plan(multisession) y1 <- future_by(warpbreaks, warpbreaks[,\"tension\"],                 function(x) lm(breaks ~ wool, data = x))  plan(sequential) y2 <- future_by(warpbreaks, warpbreaks[,\"tension\"],                 function(x) lm(breaks ~ wool, data = x))"},{"path":"https://future.apply.futureverse.org/reference/future_kernapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Smoothing Kernel in Parallel — future_kernapply","title":"Apply Smoothing Kernel in Parallel — future_kernapply","text":"future_kernapply() futurized version stats::kernapply(), .e. computes, parallel, convolution input sequence specific kernel. Parallelization takes place columns x matrix, including ts matrix.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_kernapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Smoothing Kernel in Parallel — future_kernapply","text":"","code":"future_kernapply(x, ...)  # Default S3 method future_kernapply(x, k, circular = FALSE, ...)  # S3 method for class 'ts' future_kernapply(x, k, circular = FALSE, ...)"},{"path":"https://future.apply.futureverse.org/reference/future_kernapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Smoothing Kernel in Parallel — future_kernapply","text":"x input vector, matrix, time series kernel smoothed. ... arguments passed methods. k smoothing \"tskernel\" object. circular logical indicating whether input sequence     smoothed treated circular, .e., periodic.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_kernapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Smoothing Kernel in Parallel — future_kernapply","text":"See stats::kernapply() details.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_kernapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Smoothing Kernel in Parallel — future_kernapply","text":"","code":"library(datasets) library(stats)  X <- EuStockMarkets[, 1:2] k <- kernel(\"daniell\", 50)  # a long moving average X_smooth <- future_kernapply(X, k = k)"},{"path":"https://future.apply.futureverse.org/reference/future_lapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a Function over a List or Vector via Futures — future_eapply","title":"Apply a Function over a List or Vector via Futures — future_eapply","text":"future_lapply() implements base::lapply() using futures perfect replication results, regardless future backend used. Analogously, true future_nnn() functions.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_lapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a Function over a List or Vector via Futures — future_eapply","text":"","code":"future_eapply(   env,   FUN,   ...,   all.names = FALSE,   USE.NAMES = TRUE,   future.envir = parent.frame(),   future.label = \"future_eapply-%d\" )  future_lapply(   X,   FUN,   ...,   future.envir = parent.frame(),   future.stdout = TRUE,   future.conditions = \"condition\",   future.globals = TRUE,   future.packages = NULL,   future.seed = FALSE,   future.scheduling = 1,   future.chunk.size = NULL,   future.label = \"future_lapply-%d\" )  future_replicate(   n,   expr,   simplify = \"array\",   future.seed = TRUE,   ...,   future.envir = parent.frame(),   future.label = \"future_replicate-%d\" )  future_sapply(   X,   FUN,   ...,   simplify = TRUE,   USE.NAMES = TRUE,   future.envir = parent.frame(),   future.label = \"future_sapply-%d\" )  future_tapply(   X,   INDEX,   FUN = NULL,   ...,   default = NA,   simplify = TRUE,   future.envir = parent.frame(),   future.label = \"future_tapply-%d\" )  future_vapply(   X,   FUN,   FUN.VALUE,   ...,   USE.NAMES = TRUE,   future.envir = parent.frame(),   future.label = \"future_vapply-%d\" )"},{"path":"https://future.apply.futureverse.org/reference/future_lapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a Function over a List or Vector via Futures — future_eapply","text":"env R environment. FUN function taking least one argument. .names TRUE, function also applied variables start period (.), otherwise . See base::eapply() details. USE.NAMES See base::sapply(). future.envir environment passed argument envir future::future() -. future.label character string, future assigned label sprintf(future.label, chunk_idx).  TRUE, future.label = \"future_lapply-%d\".  FALSE, labels assigned. X R object split method exists.  Typically vector-like, allowing subsetting [, data frame. future.stdout TRUE (default), standard output underlying futures captured, re-outputted soon possible. FALSE, output silenced (sinking null device outputted). NA (recommended), output intercepted. future.conditions character string conditions classes captured relayed.  default condition argument future::Future(). intercept conditions, use conditions = character(0L). Errors always relayed. future.globals logical, character vector, named list controlling globals handled. details, see section. future.packages (optional) character vector specifying packages attached R environment evaluating future. future.seed logical integer (length one seven), list length(X) pre-generated random seeds. details, see section. future.scheduling Average number futures (\"chunks\") per worker. 0.0, single future used process elements X. 1.0 TRUE, one future per worker used. 2.0, worker process two futures (enough elements X). Inf FALSE, one future per element X used. used future.chunk.size NULL. future.chunk.size average number elements per future (\"chunk\"). Inf, elements processed single future. NULL, argument future.scheduling used. n number replicates. expr R expression evaluate repeatedly. simplify See base::sapply() base::tapply(), respectively. INDEX list one factors, length X. elements coerced factors .factor(). Can also formula, useful X data frame; see f argument split() interpretation. default See base::tapply(). FUN.VALUE template required return value FUN(X[ii], ...). Types may promoted higher type within ordering logical < integer < double < complex, demoted. See base::vapply() details. ... (optional) Additional arguments passed FUN(). future_*apply() functions replicate(), future.* arguments part \\ldots passed future_lapply() used internally. Importantly, called inside another function also declares ... arguments, forget explicitly pass ... arguments future_*apply() function , pass FUN(). See example.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_lapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a Function over a List or Vector via Futures — future_eapply","text":"named (unless USE.NAMES = FALSE) list. See base::eapply() details. future_lapply(), list length names X. See base::lapply() details. future_replicate() wrapper around future_sapply() return simplified object according simplify argument. See base::replicate() details. Since future_replicate() usually involves random number generation (RNG), uses future.seed = TRUE default order produce sound random numbers regardless future backend number background workers used. future_sapply(), vector length names X. See base::sapply() details. future_tapply() returns array mode \"list\", unless simplify = TRUE (default) FUN returns scalar, case mode array returned scalars. See base::tapply() details. future_vapply(), vector length names X. See base::vapply() details.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_lapply.html","id":"global-variables","dir":"Reference","previous_headings":"","what":"Global variables","title":"Apply a Function over a List or Vector via Futures — future_eapply","text":"Argument future.globals may used control globals handled similarly globals argument used future(). Since function calls use set globals, function can gathering globals upfront (), efficient done future independently. TRUE (default), globals automatically identified gathered. character vector names specified, globals gathered. named list, globals used . cases, FUN \\ldots arguments automatically passed globals future created always needed.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_lapply.html","id":"reproducible-random-number-generation-rng-","dir":"Reference","previous_headings":"","what":"Reproducible random number generation (RNG)","title":"Apply a Function over a List or Vector via Futures — future_eapply","text":"Unless future.seed FALSE NULL, function guarantees generate exact sequence random numbers given initial seed / RNG state - regardless type futures, scheduling (\"chunking\") strategy, number workers. RNG reproducibility achieved pregenerating random seeds iterations (X) using parallel RNG streams.  iteration, seeds set calling FUN(X[[ii]], ...). Note, large length(X) may introduce large overhead. future.seed = TRUE, .Random.seed used holds parallel RNG seed, otherwise one created randomly. future.seed = FALSE, expected none FUN(X[[ii]], ...) function calls use random number generation. , informative warning error produces depending settings. See future::future() details. Using future.seed = NULL, like future.seed = FALSE without check whether random numbers generated . input, future.seed may also take fixed initial seed (integer), either full parallel RNG seed, seed generating full parallel seed. seed used generated length(X) parallel RNG streams. addition , possible specify pre-generated sequence RNG seeds list length(future.seed) == length(X) element integer seed vector can assigned .Random.seed.  One approach generate set valid RNG seeds based fixed initial seed (42L) :   Note .list(seq_along(X)) valid set .Random.seed values. cases future.seed = FALSE NULL, RNG state calling R processes function returns guaranteed \"forwarded one step\" RNG state call way regardless future.seed, future.scheduling future strategy used.  done order guarantee R script calling future_lapply() multiple times numerically reproducible given initial seed.","code":"seeds <- future_lapply(seq_along(X), FUN = function(x) .Random.seed,                        future.chunk.size = Inf, future.seed = 42L)"},{"path":"https://future.apply.futureverse.org/reference/future_lapply.html","id":"control-processing-order-of-elements","dir":"Reference","previous_headings":"","what":"Control processing order of elements","title":"Apply a Function over a List or Vector via Futures — future_eapply","text":"Attribute ordering future.chunk.size future.scheduling can used control ordering elements iterated , affects processing order order values returned. attribute can take following values: index vector - numeric vector length length(X) function     - function taking one argument called ordering(length(X)) must return index vector length length(X), e.g. function(n) rev(seq_len(n)) reverse ordering. \"random\"   - randomize ordering via random index vector sample.int(length(X)). example, future.scheduling = structure(TRUE, ordering = \"random\"). Note, elements processed order, captured standard output conditions also relayed order, order.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_lapply.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Apply a Function over a List or Vector via Futures — future_eapply","text":"implementations future_replicate(), future_sapply(), future_tapply() adopted source code corresponding base R functions, licensed GPL (>= 2) 'R Core Team' copyright holder.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_lapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a Function over a List or Vector via Futures — future_eapply","text":"","code":"## --------------------------------------------------------- ## lapply(), sapply(), tapply() ## --------------------------------------------------------- x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE)) y0 <- lapply(x, FUN = quantile, probs = 1:3/4) y1 <- future_lapply(x, FUN = quantile, probs = 1:3/4) print(y1) #> $a #>  25%  50%  75%  #> 3.25 5.50 7.75  #>  #> $beta #>       25%       50%       75%  #> 0.2516074 1.0000000 5.0536690  #>  #> $logic #> 25% 50% 75%  #> 0.0 0.5 1.0  #>  stopifnot(all.equal(y1, y0))  y0 <- sapply(x, FUN = quantile) y1 <- future_sapply(x, FUN = quantile) print(y1) #>          a        beta logic #> 0%    1.00  0.04978707   0.0 #> 25%   3.25  0.25160736   0.0 #> 50%   5.50  1.00000000   0.5 #> 75%   7.75  5.05366896   1.0 #> 100% 10.00 20.08553692   1.0 stopifnot(all.equal(y1, y0))  y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L)) y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L)) print(y1) #>          a        beta logic #> 0%    1.00  0.04978707   0.0 #> 25%   3.25  0.25160736   0.0 #> 50%   5.50  1.00000000   0.5 #> 75%   7.75  5.05366896   1.0 #> 100% 10.00 20.08553692   1.0 stopifnot(all.equal(y1, y0))   ## --------------------------------------------------------- ## Parallel Random Number Generation ## --------------------------------------------------------- # \\donttest{ ## Regardless of the future plan, the number of workers, and ## where they are, the random numbers produced are identical  plan(multisession) set.seed(0xBEEF) y1 <- future_lapply(1:5, FUN = rnorm, future.seed = TRUE) str(y1) #> List of 5 #>  $ : num -1.32 #>  $ : num [1:2] -1.5 0.293 #>  $ : num [1:3] 2.787 0.929 -0.461 #>  $ : num [1:4] -0.193 -0.184 0.504 1.255 #>  $ : num [1:5] -1.704 1.142 2.352 -1.474 -0.559  plan(sequential) set.seed(0xBEEF) y2 <- future_lapply(1:5, FUN = rnorm, future.seed = TRUE) str(y2) #> List of 5 #>  $ : num -1.32 #>  $ : num [1:2] -1.5 0.293 #>  $ : num [1:3] 2.787 0.929 -0.461 #>  $ : num [1:4] -0.193 -0.184 0.504 1.255 #>  $ : num [1:5] -1.704 1.142 2.352 -1.474 -0.559  stopifnot(all.equal(y1, y2)) # }   ## --------------------------------------------------------- ## Process chunks of data.frame rows in parallel ## --------------------------------------------------------- iris <- datasets::iris chunks <- split(iris, seq(1, nrow(iris), length.out = 3L)) y0 <- lapply(chunks, FUN = function(iris) sum(iris$Sepal.Length)) y0 <- do.call(sum, y0) y1 <- future_lapply(chunks, FUN = function(iris) sum(iris$Sepal.Length)) y1 <- do.call(sum, y1) print(y1) #> [1] 876.5 stopifnot(all.equal(y1, y0))   ## --------------------------------------------------------- ## Remember to pass down '...' arguments ## --------------------------------------------------------- ## It is important that we don't use '...' as a global variable, ## as attempted in the following not_okay_fcn() bad_fcn <- function(X, ...) {   y <- future_lapply(X, FUN = function(x) {     mean(x, ...)  ## here '...' is a global variable   })   y }  ## Instead, make sure to pass '...' via arguments all the way through good_fcn <- function(X, ...) { ## outer '...'   y <- future_lapply(X, FUN = function(x, ...) {     mean(x, ...)  ## here '...' is an argument of FUN()   }, ...) ## pass outer '...' to FUN()   y }"},{"path":"https://future.apply.futureverse.org/reference/future_mapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a Function to Multiple List or Vector Arguments — future_Filter","title":"Apply a Function to Multiple List or Vector Arguments — future_Filter","text":"future_mapply() implements base::mapply() using futures perfect replication results, regardless future backend used. Analogously mapply(), future_mapply() multivariate version future_sapply(). applies FUN first elements \\ldots argument, second elements, third elements, . Arguments recycled necessary.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_mapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a Function to Multiple List or Vector Arguments — future_Filter","text":"","code":"future_Filter(f, x, ...)  future_Map(   f,   ...,   future.envir = parent.frame(),   future.label = \"future_Map-%d\" )  future_mapply(   FUN,   ...,   MoreArgs = NULL,   SIMPLIFY = TRUE,   USE.NAMES = TRUE,   future.envir = parent.frame(),   future.stdout = TRUE,   future.conditions = \"condition\",   future.globals = TRUE,   future.packages = NULL,   future.seed = FALSE,   future.scheduling = 1,   future.chunk.size = NULL,   future.label = \"future_mapply-%d\" )  future_.mapply(FUN, dots, MoreArgs, ..., future.label = \"future_.mapply-%d\")"},{"path":"https://future.apply.futureverse.org/reference/future_mapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a Function to Multiple List or Vector Arguments — future_Filter","text":"f function arity \\(k\\) future_Map() called \\(k\\) arguments. x vector-like object iterate . future.envir environment passed argument envir future::future() -. future.label character string, future assigned label sprintf(future.label, chunk_idx).  TRUE, future.label = \"future_lapply-%d\".  FALSE, labels assigned. FUN function apply, found via base::match.fun(). MoreArgs list arguments FUN. SIMPLIFY logical character string; attempt reduce result vector, matrix higher dimensional array; see simplify argument base::sapply(). USE.NAMES logical; use names first \\ldots argument names, character vector, use character vector names. future.stdout TRUE (default), standard output underlying futures captured, re-outputted soon possible. FALSE, output silenced (sinking null device outputted). NA (recommended), output intercepted. future.conditions character string conditions classes captured relayed.  default condition argument future::Future(). intercept conditions, use conditions = character(0L). Errors always relayed. future.globals logical, character vector, named list controlling globals handled. details, see future_lapply(). future.packages (optional) character vector specifying packages attached R environment evaluating future. future.seed logical integer (length one seven), list max(lengths(list(...))) pre-generated random seeds. details, see future_lapply(). future.scheduling Average number futures (\"chunks\") per worker. 0.0, single future used process elements X. 1.0 TRUE, one future per worker used. 2.0, worker process two futures (enough elements X). Inf FALSE, one future per element X used. used future.chunk.size NULL. future.chunk.size average number elements per future (\"chunk\"). Inf, elements processed single future. NULL, argument future.scheduling used. dots list arguments vectorize (vectors lists strictly positive length, zero length). ... Arguments vectorize , recycled common length, zero one length zero.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_mapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a Function to Multiple List or Vector Arguments — future_Filter","text":"See base::Filter() details. future_Map() simple wrapper future_mapply() attempt simplify result. See base::Map() details. future_mapply() returns list, SIMPLIFY = TRUE, vector, array list.  See base::mapply() details. future_.mapply() returns list. See base::.mapply() details.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_mapply.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a Function to Multiple List or Vector Arguments — future_Filter","text":"Note base::.mapply(), future_.mapply() modeled listed \"internal\" function R despite exported.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_mapply.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Apply a Function to Multiple List or Vector Arguments — future_Filter","text":"implementations future_Filter() adopted source code corresponding base R function Filter(), licensed GPL (>= 2) 'R Core Team' copyright holder. implementations future_Map() adopted source code corresponding base R function Map(), licensed GPL (>= 2) 'R Core Team' copyright holder.","code":""},{"path":"https://future.apply.futureverse.org/reference/future_mapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a Function to Multiple List or Vector Arguments — future_Filter","text":"","code":"## --------------------------------------------------------- ## Filter() ## --------------------------------------------------------- is_even <- function(x) { x %% 2 == 0 } x <- sample.int(100, size = 1000, replace = TRUE) y <- future_Filter(is_even, x)   ## --------------------------------------------------------- ## mapply() ## --------------------------------------------------------- y0 <- mapply(rep, 1:4, 4:1) y1 <- future_mapply(rep, 1:4, 4:1) stopifnot(identical(y1, y0))  y0 <- mapply(rep, times = 1:4, x = 4:1) y1 <- future_mapply(rep, times = 1:4, x = 4:1) stopifnot(identical(y1, y0))  y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42)) y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42)) stopifnot(identical(y1, y0))  y0 <- mapply(function(x, y) seq_len(x) + y,              c(a =  1, b = 2, c = 3),  # names from first              c(A = 10, B = 0, C = -10)) y1 <- future_mapply(function(x, y) seq_len(x) + y,                     c(a =  1, b = 2, c = 3),  # names from first                     c(A = 10, B = 0, C = -10)) stopifnot(identical(y1, y0))  word <- function(C, k) paste(rep.int(C, k), collapse = \"\") y0 <- mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE) y1 <- future_mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE) stopifnot(identical(y1, y0))   ## --------------------------------------------------------- ## Parallel Random Number Generation ## --------------------------------------------------------- # \\donttest{ ## Regardless of the future plan, the number of workers, and ## where they are, the random numbers produced are identical  plan(multisession) set.seed(0xBEEF) y1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,                     MoreArgs = list(min = 1), future.seed = TRUE) print(y1) #> [[1]] #> [1] 1.094084 #>  #> [[2]] #> [1] 1.133518 1.415726 #>  #> [[3]] #> [1] 3.992017 3.395174 3.470525 #>  #> [[4]] #> [1] 2.693828 1.588631 2.708467 4.411477 #>   plan(sequential) set.seed(0xBEEF) y2 <- future_mapply(stats::runif, n = 1:4, max = 2:5,                     MoreArgs = list(min = 1), future.seed = TRUE) print(y2) #> [[1]] #> [1] 1.094084 #>  #> [[2]] #> [1] 1.133518 1.415726 #>  #> [[3]] #> [1] 3.992017 3.395174 3.470525 #>  #> [[4]] #> [1] 2.693828 1.588631 2.708467 4.411477 #>   stopifnot(all.equal(y1, y2)) # }"},{"path":"https://future.apply.futureverse.org/reference/makeChunks.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Chunks of Index Vectors — makeChunks","title":"Create Chunks of Index Vectors — makeChunks","text":"internal function.","code":""},{"path":"https://future.apply.futureverse.org/reference/makeChunks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Chunks of Index Vectors — makeChunks","text":"","code":"makeChunks(   nbrOfElements,   nbrOfWorkers,   future.scheduling = 1,   future.chunk.size = NULL )"},{"path":"https://future.apply.futureverse.org/reference/makeChunks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Chunks of Index Vectors — makeChunks","text":"nbrOfElements (integer) Total number elements iterate . nbrOfWorkers (integer) Number workers available. future.scheduling (numeric) strictly positive scalar. used argument future.chunk.size NULL. future.chunk.size (numeric) maximum number elements per chunk, NULL.  NULL, chunk sizes given future.scheduling argument.","code":""},{"path":"https://future.apply.futureverse.org/reference/makeChunks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Chunks of Index Vectors — makeChunks","text":"list chunks, chunk integer vector unique indices [1, nbrOfElements].  union chunks holds nbrOfElements elements equals 1:nbrOfElements. nbrOfElements == 0, empty list returned.","code":""},{"path":"https://future.apply.futureverse.org/reference/makeChunks.html","id":"control-processing-order-of-elements","dir":"Reference","previous_headings":"","what":"Control processing order of elements","title":"Create Chunks of Index Vectors — makeChunks","text":"Attribute ordering future.chunk.size future.scheduling can used control ordering elements iterated , affects processing order order values returned. attribute can take following values: index vector - numeric vector length nbrOfElements specifying elements remapped function     - function taking one argument called ordering(nbrOfElements) must return index vector length nbrOfElements, e.g. function(n) rev(seq_len(n)) reverse ordering. \"random\"   - randomize ordering via random index vector sample.int(nbrOfElements).","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-1200","dir":"Changelog","previous_headings":"","what":"Version 1.20.0","title":"Version 1.20.0","text":"CRAN release: 2025-06-06","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"significant-changes-1-20-0","dir":"Changelog","previous_headings":"","what":"Significant changes","title":"Version 1.20.0","text":"future.apply functions now cancel remaining non-resolved futures one futures produces error, user interrupt (Ctrl-C) detected. backend futures running supports , canceled futures also interrupted, results compute resources freed sooner future.apply function returning sooner.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-1-20-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.20.0","text":"Added future_Filter(), parallel version base::Filter(). Added future_kernapply(), parallel version stats::kernapply(). Now future.apply lets future take care generation parallel RNG seed. Consolidating random number generation core package allow us add central support custom parallel RNG methods beyond built-L’Ecuyer-CMRG method.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-20-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.20.0","text":"Specifying function FUN future_by() character string defunct. specified function, e.g. FUN    = sqrt FUN = `[[`, base::() requires. Use string deprecated since future.apply 1.10.0 (2022-11-04).","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-1113","dir":"Changelog","previous_headings":"","what":"Version 1.11.3","title":"Version 1.11.3","text":"CRAN release: 2024-10-27","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-11-3","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.11.3","text":"Use future.seed = TRUE result error !(seed_next != seed) TRUE rare cases.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-1112","dir":"Changelog","previous_headings":"","what":"Version 1.11.2","title":"Version 1.11.2","text":"CRAN release: 2024-03-28","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"miscellaneous-1-11-2","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.11.2","text":"Relaxed one unit test triggered error 32-bit architectures.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-1111","dir":"Changelog","previous_headings":"","what":"Version 1.11.1","title":"Version 1.11.1","text":"CRAN release: 2023-12-21","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-11-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.11.1","text":"Option future.globals.maxSize never passed parallel workers. assertion argument INDEX future_tapply() fail another error R (< 3.6.0), INDEX incorrect first place.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-1110","dir":"Changelog","previous_headings":"","what":"Version 1.11.0","title":"Version 1.11.0","text":"CRAN release: 2023-05-21","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"significant-changes-1-11-0","dir":"Changelog","previous_headings":"","what":"Significant Changes","title":"Version 1.11.0","text":"future_tapply() now accepts data frames input, just tapply() R (>= 4.3.0). R (>= 4.3.0), future_tapply(X, INDEX, ...) now accepts INDEX formula X data frames, just tapply() R (>= 4.3.0). error produced used R (< 4.3.0). R (>= 4.3.0), future_by(X, INDICES, ...) now accepts INDICES formula X data frames, just () R (>= 4.3.0). error produced used R (< 4.3.0).","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-1-11-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.11.0","text":"Now future operators %globals%, %seed%, %stdout% can used control corresponding future.* arguments, e.g. y <- future_lapply(1:3, FUN = my_fun) %seed% TRUE y <- future_lapply(1:3, FUN = my_fun, future.seed = TRUE).","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-11-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.11.0","text":"Contrary lapply(X, ...), future_lapply(X, ...) failed use method-specific [[ subsetting, class X implemented one. future_mapply() functions problem. reason X partitioned chunks, lose class attribute subsetting [[.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-1100","dir":"Changelog","previous_headings":"","what":"Version 1.10.0","title":"Version 1.10.0","text":"CRAN release: 2022-11-05","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-10-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.10.0","text":"Functions future_eapply(), future_lapply(), future_sapply(), future_vapply() failed FUN specified name function rather function object , e.g. future_lapply(1:3, FUN = \"sqrt\").","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-10-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.10.0","text":"Specifying function FUN future_by() character string deprecated, base::() support . specified function, e.g. FUN = sqrt FUN =    `[[`.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-191","dir":"Changelog","previous_headings":"","what":"Version 1.9.1","title":"Version 1.9.1","text":"CRAN release: 2022-09-07","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-9-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.9.1","text":"warnings errors showed wrong call.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"miscellaneous-1-9-1","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"Version 1.9.1","text":"Fix HTML5 issues help pages.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-190","dir":"Changelog","previous_headings":"","what":"Version 1.9.0","title":"Version 1.9.0","text":"CRAN release: 2022-04-25","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"signficant-changes-1-9-0","dir":"Changelog","previous_headings":"","what":"Signficant Changes","title":"Version 1.9.0","text":"future_mapply() future_Map() updated match new behavior mapply() Map() R (>= 4.2.0), follows “max--0--” recycling rule.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"performance-1-9-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.9.0","text":"Now captured standard output conditions deleted soon relayed. requires future (>= 1.25.0).","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"deprecated-and-defunct-1-9-0","dir":"Changelog","previous_headings":"","what":"Deprecated and Defunct","title":"Version 1.9.0","text":"Removed moot argument future.lazy functions. Regardless setting TRUE FALSE, futures resolved momentarily always apply returned.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-181","dir":"Changelog","previous_headings":"","what":"Version 1.8.1","title":"Version 1.8.1","text":"CRAN release: 2021-08-10","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-8-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.8.1","text":"citEntry() CITATION used argument notes instead note.","code":""},{"path":[]},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-1-8-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.8.0","text":"Add argument future.envir future_nnn() functions, passed argument envir future(). Add option future.apply.debug debugging features specific package. defaults option future.debug.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"performance-1-8-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.8.0","text":"Internal getGlobalsAndPackagesXApply() now avoids calculating object size ... arguments option future.globals.maxSize +Inf.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-8-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.8.0","text":"f <- function(...) future_lapply(X, function(x) list(...));    f(=1) produce error ’unused argument (= 1)” upcoming release future 1.22.0.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-170","dir":"Changelog","previous_headings":"","what":"Version 1.7.0","title":"Version 1.7.0","text":"CRAN release: 2021-01-04","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-1-7-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.7.0","text":"automatic capturing conditions can disabled specifying future.conditions = NULL. Warnings errors using RNG without specifying future.seed now tailored future.apply package.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-160","dir":"Changelog","previous_headings":"","what":"Version 1.6.0","title":"Version 1.6.0","text":"CRAN release: 2020-07-01","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"signficant-changes-1-6-0","dir":"Changelog","previous_headings":"","what":"Signficant Changes","title":"Version 1.6.0","text":"future_apply() gained argument simplify, added R-devel (become R 4.1.0).","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-6-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.6.0","text":"future_apply(X, FUN, ...) pass future.* arguments except future.globals, future.packages, future.labels FUN function instead processing locally. often result FUN producing error “unused argument”. also affected future.seed applied, means FUN functions produce error, non-reproducible results produced.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-150","dir":"Changelog","previous_headings":"","what":"Version 1.5.0","title":"Version 1.5.0","text":"CRAN release: 2020-04-17","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-1-5-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.5.0","text":"Add future_.mapply() corresponding .mapply() base package.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-5-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.5.0","text":"future_mapply() chunk MoreArgs future.seed =    TRUE.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-140","dir":"Changelog","previous_headings":"","what":"Version 1.4.0","title":"Version 1.4.0","text":"CRAN release: 2020-01-07","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-1-4-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.4.0","text":"Now future_nnn() functions set label future reflects name future_nnn() function index chunk, e.g. \"future_lapply-3\". format can controlled argument future.label.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"performance-1-4-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 1.4.0","text":"assertion maximum size globals per chunk now significantly faster future_apply().","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-4-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.4.0","text":"future_lapply(X) future_mapply(FUN, X) drop names argument returned empty list length(X) == 0. Package set .Random.seed NULL, instead removing , turn produce warning “‘.Random.seed’ integer vector type ‘NULL’, ignored” next random number generated.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-130","dir":"Changelog","previous_headings":"","what":"Version 1.3.0","title":"Version 1.3.0","text":"CRAN release: 2019-06-18","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-1-3-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.3.0","text":"Now future.conditions defaults argument conditions future::future(). latter changes, package follow. Debug messages now prepended timestamp.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-3-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.3.0","text":"error “sprintf(…) : ‘fmt’ length exceeds maximal format length 8192” produced debugging tried report many globals.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-120","dir":"Changelog","previous_headings":"","what":"Version 1.2.0","title":"Version 1.2.0","text":"CRAN release: 2019-03-07","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-1-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.2.0","text":"Added future_by().","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-2-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.2.0","text":"Attributes add ignore argument future.globals ignored although support added future (>= 1.10.0). Validation L’Ecuyer-CMRG RNG seeds failed recent R devel.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-110","dir":"Changelog","previous_headings":"","what":"Version 1.1.0","title":"Version 1.1.0","text":"CRAN release: 2019-01-17","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"signficant-changes-1-1-0","dir":"Changelog","previous_headings":"","what":"Signficant Changes","title":"Version 1.1.0","text":"Added argument future.stdout future.conditions controlling whether standard output conditions (e.g. messages warnings) produced evaluation futures captured relayed . Standard output guaranteed relayed order using sequential processing. Analogously conditions. However, standard output always relayed conditions. Errors always relayed. Relaying non-error conditions requires future (>= 1.11.0).","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-1-1-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.1.0","text":"Elements can processed random order setting attribute ordering \"random\" argument future.chunk.size future.scheduling, e.g. future.chunk.size = structure(TRUE,    ordering = \"random\"). can help improve load balancing cases correlation processing time ordering elements. Note order returned values affected randomizing processing order. Swapped order arguments future.lazy future.seed consistent ditto arguments future::future().","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-101","dir":"Changelog","previous_headings":"","what":"Version 1.0.1","title":"Version 1.0.1","text":"CRAN release: 2018-08-26","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"documentation--licence-1-0-1","dir":"Changelog","previous_headings":"","what":"Documentation / Licence","title":"Version 1.0.1","text":"license GPL (>= 2). Previously documented GPL (>= 2.1) non-existing GPL version.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-0-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.0.1","text":"list objects X X != .list(X), future_lapply(X) give result lapply(X). Analogously future_vapply(X). future_mapply() drop class attribute elements iterated , .subset() used internally instead `[`(). instance, iteration Date objects affected.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-100","dir":"Changelog","previous_headings":"","what":"Version 1.0.0","title":"Version 1.0.0","text":"CRAN release: 2018-06-20","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"signficant-changes-1-0-0","dir":"Changelog","previous_headings":"","what":"Signficant Changes","title":"Version 1.0.0","text":"License changed LGPL (>= 2.1) GPL (>= 2) make sure compatible source code adopted R base’s apply(), Map(), replicate(), sapply(), tapply(), GPL (>= 2).","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-1-0-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 1.0.0","text":"Added future_apply(), future_mapply(), future_Map(). Added argument future.chunk.size alternative argument future.scheduling controlling average number elements processed per future (“chunk”). R 3.5.0, parallel package introduced argument chunk.size. maximum total size globals allowed (option future.globals.maxSize) per future (“chunk”) now scaled number elements processed future (“chunk”) making protection approximately invariant amount chunking (arguments future.scheduling future.chunk.size).","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"bug-fixes-1-0-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"Version 1.0.0","text":"future_lapply(X, ...) search globals X. future_vapply() return dimension names vapply() FUN.VALUE names FUN(X[[1]]) .","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"software-quality-1-0-0","dir":"Changelog","previous_headings":"","what":"Software Quality","title":"Version 1.0.0","text":"Test code coverage 100%.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-020","dir":"Changelog","previous_headings":"","what":"Version 0.2.0","title":"Version 0.2.0","text":"CRAN release: 2018-05-01","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.2.0","text":"Added future_eapply(), future_tapply(), future_vapply(), future_replicate().","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"version-010","dir":"Changelog","previous_headings":"","what":"Version 0.1.0","title":"Version 0.1.0","text":"CRAN release: 2018-01-15 Package submitted CRAN.","code":""},{"path":[]},{"path":"https://future.apply.futureverse.org/news/index.html","id":"documentation-0-0-3","dir":"Changelog","previous_headings":"","what":"Documentation","title":"Version 0.0.3","text":"Vignette now covers basics package describes role R package ecosystem together road map going forward.","code":""},{"path":"https://future.apply.futureverse.org/news/index.html","id":"software-quality-0-0-3","dir":"Changelog","previous_headings":"","what":"Software Quality","title":"Version 0.0.3","text":"Added package tests. Code coverage currently 100%.","code":""},{"path":[]},{"path":"https://future.apply.futureverse.org/news/index.html","id":"performance-0-0-2","dir":"Changelog","previous_headings":"","what":"Performance","title":"Version 0.0.2","text":"future_lapply(x, ...) now much faster memory efficient large x vectors uses internal fold() function efficient (memory speed) version base::Reduce(f, x), especially length(x) large.","code":""},{"path":[]},{"path":"https://future.apply.futureverse.org/news/index.html","id":"new-features-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"New Features","title":"Version 0.0.0-9000","text":"Added future_sapply(). Added future_lapply() - originally future package. Created package.","code":""}]
